// Generated by Ignite ignite.com/cli

import { SigningStargateClient, DeliverTxResponse, StdFee } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { QueryParamsRequest } from "./types/permos/permos/query";
import { QueryParamsResponse } from "./types/permos/permos/query";
import { MsgUpdateParamsResponse } from "./types/permos/permos/tx";
import { MsgUpdatePermosResponse } from "./types/permos/permos/tx";
import { QueryGetPermosResponse } from "./types/permos/permos/query";
import { MsgCreatePermosResponse } from "./types/permos/permos/tx";
import { MsgDeletePermosResponse } from "./types/permos/permos/tx";
import { Params } from "./types/permos/permos/params";
import { MsgUpdateParams } from "./types/permos/permos/tx";
import { Permos } from "./types/permos/permos/permos";
import { QueryAllPermosResponse } from "./types/permos/permos/query";
import { MsgUpdatePermos } from "./types/permos/permos/tx";
import { QueryGetPermosRequest } from "./types/permos/permos/query";
import { QueryAllPermosRequest } from "./types/permos/permos/query";
import { MsgCreatePermos } from "./types/permos/permos/tx";
import { MsgDeletePermos } from "./types/permos/permos/tx";
import { GenesisState } from "./types/permos/permos/genesis";


export { QueryParamsRequest, QueryParamsResponse, MsgUpdateParamsResponse, MsgUpdatePermosResponse, QueryGetPermosResponse, MsgCreatePermosResponse, MsgDeletePermosResponse, Params, MsgUpdateParams, Permos, QueryAllPermosResponse, MsgUpdatePermos, QueryGetPermosRequest, QueryAllPermosRequest, MsgCreatePermos, MsgDeletePermos, GenesisState };

type sendQueryParamsRequestParams = {
  value: QueryParamsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsResponseParams = {
  value: QueryParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdatePermosResponseParams = {
  value: MsgUpdatePermosResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetPermosResponseParams = {
  value: QueryGetPermosResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreatePermosResponseParams = {
  value: MsgCreatePermosResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeletePermosResponseParams = {
  value: MsgDeletePermosResponse,
  fee?: StdFee,
  memo?: string
};

type sendParamsParams = {
  value: Params,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsParams = {
  value: MsgUpdateParams,
  fee?: StdFee,
  memo?: string
};

type sendPermosParams = {
  value: Permos,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllPermosResponseParams = {
  value: QueryAllPermosResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdatePermosParams = {
  value: MsgUpdatePermos,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetPermosRequestParams = {
  value: QueryGetPermosRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllPermosRequestParams = {
  value: QueryAllPermosRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreatePermosParams = {
  value: MsgCreatePermos,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeletePermosParams = {
  value: MsgDeletePermos,
  fee?: StdFee,
  memo?: string
};

type sendGenesisStateParams = {
  value: GenesisState,
  fee?: StdFee,
  memo?: string
};


type queryParamsRequestParams = {
  value: QueryParamsRequest,
};

type queryParamsResponseParams = {
  value: QueryParamsResponse,
};

type msgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
};

type msgUpdatePermosResponseParams = {
  value: MsgUpdatePermosResponse,
};

type queryGetPermosResponseParams = {
  value: QueryGetPermosResponse,
};

type msgCreatePermosResponseParams = {
  value: MsgCreatePermosResponse,
};

type msgDeletePermosResponseParams = {
  value: MsgDeletePermosResponse,
};

type paramsParams = {
  value: Params,
};

type msgUpdateParamsParams = {
  value: MsgUpdateParams,
};

type permosParams = {
  value: Permos,
};

type queryAllPermosResponseParams = {
  value: QueryAllPermosResponse,
};

type msgUpdatePermosParams = {
  value: MsgUpdatePermos,
};

type queryGetPermosRequestParams = {
  value: QueryGetPermosRequest,
};

type queryAllPermosRequestParams = {
  value: QueryAllPermosRequest,
};

type msgCreatePermosParams = {
  value: MsgCreatePermos,
};

type msgDeletePermosParams = {
  value: MsgDeletePermos,
};

type genesisStateParams = {
  value: GenesisState,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendQueryParamsRequest({ value, fee, memo }: sendQueryParamsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsRequest({ value: QueryParamsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsResponse({ value, fee, memo }: sendQueryParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsResponse({ value: QueryParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParamsResponse({ value, fee, memo }: sendMsgUpdateParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParamsResponse({ value: MsgUpdateParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdatePermosResponse({ value, fee, memo }: sendMsgUpdatePermosResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdatePermosResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdatePermosResponse({ value: MsgUpdatePermosResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdatePermosResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetPermosResponse({ value, fee, memo }: sendQueryGetPermosResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetPermosResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetPermosResponse({ value: QueryGetPermosResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetPermosResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreatePermosResponse({ value, fee, memo }: sendMsgCreatePermosResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreatePermosResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreatePermosResponse({ value: MsgCreatePermosResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreatePermosResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeletePermosResponse({ value, fee, memo }: sendMsgDeletePermosResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeletePermosResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDeletePermosResponse({ value: MsgDeletePermosResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeletePermosResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendParams({ value, fee, memo }: sendParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.params({ value: Params.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParams({ value, fee, memo }: sendMsgUpdateParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPermos({ value, fee, memo }: sendPermosParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPermos: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.permos({ value: Permos.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPermos: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllPermosResponse({ value, fee, memo }: sendQueryAllPermosResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllPermosResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllPermosResponse({ value: QueryAllPermosResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllPermosResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdatePermos({ value, fee, memo }: sendMsgUpdatePermosParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdatePermos: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdatePermos({ value: MsgUpdatePermos.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdatePermos: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetPermosRequest({ value, fee, memo }: sendQueryGetPermosRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetPermosRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetPermosRequest({ value: QueryGetPermosRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetPermosRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllPermosRequest({ value, fee, memo }: sendQueryAllPermosRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllPermosRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllPermosRequest({ value: QueryAllPermosRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllPermosRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreatePermos({ value, fee, memo }: sendMsgCreatePermosParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreatePermos: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreatePermos({ value: MsgCreatePermos.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreatePermos: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeletePermos({ value, fee, memo }: sendMsgDeletePermosParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeletePermos: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDeletePermos({ value: MsgDeletePermos.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeletePermos: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGenesisState({ value, fee, memo }: sendGenesisStateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.genesisState({ value: GenesisState.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		queryParamsRequest({ value }: queryParamsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/permos.permos.QueryParamsRequest", value: QueryParamsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryParamsResponse({ value }: queryParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/permos.permos.QueryParamsResponse", value: QueryParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParamsResponse({ value }: msgUpdateParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/permos.permos.MsgUpdateParamsResponse", value: MsgUpdateParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdatePermosResponse({ value }: msgUpdatePermosResponseParams): EncodeObject {
			try {
				return { typeUrl: "/permos.permos.MsgUpdatePermosResponse", value: MsgUpdatePermosResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdatePermosResponse: Could not create message: ' + e.message)
			}
		},
		
		queryGetPermosResponse({ value }: queryGetPermosResponseParams): EncodeObject {
			try {
				return { typeUrl: "/permos.permos.QueryGetPermosResponse", value: QueryGetPermosResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetPermosResponse: Could not create message: ' + e.message)
			}
		},
		
		msgCreatePermosResponse({ value }: msgCreatePermosResponseParams): EncodeObject {
			try {
				return { typeUrl: "/permos.permos.MsgCreatePermosResponse", value: MsgCreatePermosResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreatePermosResponse: Could not create message: ' + e.message)
			}
		},
		
		msgDeletePermosResponse({ value }: msgDeletePermosResponseParams): EncodeObject {
			try {
				return { typeUrl: "/permos.permos.MsgDeletePermosResponse", value: MsgDeletePermosResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeletePermosResponse: Could not create message: ' + e.message)
			}
		},
		
		params({ value }: paramsParams): EncodeObject {
			try {
				return { typeUrl: "/permos.permos.Params", value: Params.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Params: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParams({ value }: msgUpdateParamsParams): EncodeObject {
			try {
				return { typeUrl: "/permos.permos.MsgUpdateParams", value: MsgUpdateParams.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message)
			}
		},
		
		permos({ value }: permosParams): EncodeObject {
			try {
				return { typeUrl: "/permos.permos.Permos", value: Permos.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Permos: Could not create message: ' + e.message)
			}
		},
		
		queryAllPermosResponse({ value }: queryAllPermosResponseParams): EncodeObject {
			try {
				return { typeUrl: "/permos.permos.QueryAllPermosResponse", value: QueryAllPermosResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllPermosResponse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdatePermos({ value }: msgUpdatePermosParams): EncodeObject {
			try {
				return { typeUrl: "/permos.permos.MsgUpdatePermos", value: MsgUpdatePermos.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdatePermos: Could not create message: ' + e.message)
			}
		},
		
		queryGetPermosRequest({ value }: queryGetPermosRequestParams): EncodeObject {
			try {
				return { typeUrl: "/permos.permos.QueryGetPermosRequest", value: QueryGetPermosRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetPermosRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllPermosRequest({ value }: queryAllPermosRequestParams): EncodeObject {
			try {
				return { typeUrl: "/permos.permos.QueryAllPermosRequest", value: QueryAllPermosRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllPermosRequest: Could not create message: ' + e.message)
			}
		},
		
		msgCreatePermos({ value }: msgCreatePermosParams): EncodeObject {
			try {
				return { typeUrl: "/permos.permos.MsgCreatePermos", value: MsgCreatePermos.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreatePermos: Could not create message: ' + e.message)
			}
		},
		
		msgDeletePermos({ value }: msgDeletePermosParams): EncodeObject {
			try {
				return { typeUrl: "/permos.permos.MsgDeletePermos", value: MsgDeletePermos.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeletePermos: Could not create message: ' + e.message)
			}
		},
		
		genesisState({ value }: genesisStateParams): EncodeObject {
			try {
				return { typeUrl: "/permos.permos.GenesisState", value: GenesisState.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GenesisState: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const IgntModule = (test: IgniteClient) => {
	return {
		module: {
			PermosPermos: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default IgntModule;